#pySerial Utilities for IOx

The scripts here use the [pySerial](https://github.com/pyserial/pyserial) serial interface capabilities to 
automate these common device configuration tasks:

 - [config_load.py](./config_load.py) - Generate a configuration from a template and configure devices so that they 
 have IP connectivity. 
 - [bundle_install.py](./bundle_install.py) - Install bundles and images via TFTP, assuming IP connectivity and an
 available TFTP server.
 - [clear_reload.py](./clear_reload.py) - Use the "clear start" and "reload" commands to reset a device as though the 
 reset button had been used.
 
 All of the scripts act against devices connected via console cables, and use common utilities in 
 [cli_util.py](./cli_util.py). 
 
 The config_load.py script will generate configurations for a range of networks that may require route entries to be
 reachable from your laptop, for example. On OSX, for example, given a device configured for the 10.42.0.0 networks, 
 you may need to use this command to make the GOS on that device reachable.
 
 ```bash
 sudo route -n add -net 10.42.0.0/16  10.42.1.1
 ```
 
 The typical way that the scripts might be used is to clear and reload devices, with clear_reload.py, so that they are 
 at factory settings,i.e. a known state. Then you could load configurations generated by config_load.py. Occasionally,
 as bundles and images are updates, you may need to use bundle_install.py to load and install new bundles and images.
 Note that the configurations generated by config_load.py can also install new bundles and images, but they have to be
 in flash memory first, which is what bundle_install.py will do for you.
 
 It is useful to imagine this as the first step in a CI/CD pipeline where the environment is reset, and then 
 automatically configured to a known good state before automated testing.
 
 The scripts use a form on [expect](https://en.wikipedia.org/wiki/Expect) like interaction, where the code attempts to 
 mimic what a person using the console would expect to see and do. This is tricky, to say the least. The main issues 
 tend to be with timing, and ensuring that the device is in the right state. If not, the response from the device 
 console isn't always what is expected at a given point in the flow. This could be because the device is booting more 
 slowly than expected, or some environmental condition is causing errors, or it was not reset, or it is is some
 unexpected state at a given stage in the processing.
 
 The upshot is that you need to try these scripts a few times and watch what they do in your environment, before
 letting them loose unsupervised.
 
 The notes at https://github.com/DevOps4Networks/IOX-Notes may also be useful.
 
##Notes
 You may see an exception message such as: "[Errno 16] Resource busy: '/dev/cu.SLAB_USBtoUART6'".
        
 You can try the following to release the resource.
 
 ```bash       
 lsof | grep UART
 screen    2786          <username>    5u      CHR              17,13      0t189             725 /dev/cu.SLAB_USBtoUART6
 kill -9 2786
 lsof | grep UART
 $ 
 ```   
 
#Issues
 
Please feel free to create issues against this project if you have any questions, input, advice or just want to say 
something nice :-) 

I can't promise to address all issues, but I will do my best. 
